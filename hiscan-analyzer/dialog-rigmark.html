<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>阈值分割</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/element-plus/dist/index.css"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        overflow: hidden;
      }

      /* 自定义标题栏 */
      .custom-titlebar {
        height: 50px;
        border-bottom: 1px solid #ddd;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        -webkit-app-region: drag;
      }

      .titlebar-title {
        font-size: 16px;
        font-weight: 500;
      }

      .titlebar-close {
        width: 32px;
        height: 32px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        -webkit-app-region: no-drag;
        font-size: 20px;
      }

      .titlebar-close:hover {
        background: #eee;
      }

      #app {
        width: 100%;
        height: calc(100vh - 50px);
        padding: 24px;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
      }

      .form-item {
        margin-bottom: 24px;
      }

      .form-label {
        display: block;
        margin-bottom: 12px;
        font-size: 14px;
        font-weight: 500;
      }

      #histogram {
        width: 100%;
        height: 200px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #f9f9f9;
      }

      .dialog-footer {
        padding-top: 16px;
        border-top: 1px solid #ddd;
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        margin-top: auto;
      }
    </style>
  </head>
  <body>
    <!-- 自定义标题栏 -->
    <div class="custom-titlebar">
      <div class="titlebar-title">阈值分割</div>
      <div class="titlebar-close" id="close-btn">×</div>
    </div>

    <div id="app">
      <div class="form-item">
        <label class="form-label">最小值 HU ({{ rigMarkMin }})</label>
        <el-slider
          v-model="rigMarkMin"
          :min="histogramMinValue"
          :max="histogramMaxValue"
          :step="1"
          show-input
          :input-size="'small'"
        />
      </div>

      <div class="form-item">
        <label class="form-label">最大值 HU ({{ rigMarkMax }})</label>
        <el-slider
          v-model="rigMarkMax"
          :min="histogramMinValue"
          :max="histogramMaxValue"
          :step="1"
          show-input
          :input-size="'small'"
        />
      </div>

      <div class="form-item">
        <label class="form-label">直方图预览（Y轴为对数尺度）</label>
        <canvas id="histogram"></canvas>
      </div>

      <div class="form-item">
        <label class="form-label">掩膜颜色</label>
        <el-color-picker v-model="previewColor" />
      </div>

      <div class="dialog-footer">
        <button id="cancel-btn" class="el-button" @click="cancel">取消</button>
        <button
          id="apply-btn"
          class="el-button el-button--primary"
          @click="apply"
        >
          应用
        </button>
      </div>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus"></script>
    <script>
      const { createApp, ref, onMounted, watch, nextTick } = Vue;

      const app = createApp({
        setup() {
          const rigMarkMin = ref(0);
          const rigMarkMax = ref(255);
          const histogramMinValue = ref(0);
          const histogramMaxValue = ref(255);
          const previewColor = ref("#ffff00");
          const histogramData = ref([]);
          let sessionId = "";

          onMounted(async () => {
            console.log("[Dialog] Mounted");

            // 初始化函数
            function initializeDialog(data: any) {
              console.log("[Dialog] Initializing with data:", {
                sessionId: data.sessionId,
                minValue: data.minValue,
                maxValue: data.maxValue,
                histogramLength:
                  (data.histogramData?.length || 0) + (data.data?.length || 0),
              });

              if (data.sessionId) sessionId = data.sessionId;

              if (typeof data.defaultColor === "string" && data.defaultColor) {
                previewColor.value = data.defaultColor;
              }

              const minVal = data.minValue !== undefined ? data.minValue : 0;
              const maxVal = data.maxValue !== undefined ? data.maxValue : 255;

              histogramMinValue.value = minVal;
              histogramMaxValue.value = maxVal;
              rigMarkMin.value = minVal;
              rigMarkMax.value = maxVal;

              const raw =
                data.histogramData !== undefined
                  ? data.histogramData
                  : data.data;

              if (raw) {
                if (Array.isArray(raw)) {
                  histogramData.value = raw;
                } else if (typeof raw === "string") {
                  try {
                    histogramData.value = JSON.parse(raw);
                  } catch (e) {
                    console.error(
                      "[Dialog] Failed to parse histogram data:",
                      e
                    );
                  }
                }
                console.log(
                  "[Dialog] Histogram data loaded, length:",
                  histogramData.value.length
                );
              }

              nextTick().then(() => {
                console.log("[Dialog] Drawing histogram");
                drawHistogram();
              });
            }

            // 优先监听 IPC 数据（开发和生产环境都使用）
            if (window.electronAPI) {
              console.log("[Dialog] Listening for IPC data...");
              window.electronAPI.on("dialog:init-data", (data: any) => {
                console.log("[Dialog] Received init data via IPC");
                initializeDialog(data);
              });

              // Notify main process that renderer is ready to receive init data.
              // This avoids a race where main sends init-data before the listener is registered.
              window.electronAPI.send("dialog:ready");
            } else {
              console.error("[Dialog] electronAPI not available!");
            }

            // 监听值变化
            watch([rigMarkMin, rigMarkMax], () => {
              drawHistogram();
              updatePreview();
            });

            watch(previewColor, () => {
              updatePreview();
            });
          });

          function drawHistogram() {
            console.log("[drawHistogram] Called");
            const canvas = document.getElementById("histogram");
            console.log("[drawHistogram] Canvas:", canvas);
            console.log(
              "[drawHistogram] Histogram data length:",
              histogramData.value.length
            );
            console.log(
              "[drawHistogram] Histogram data sample:",
              histogramData.value.slice(0, 10)
            );

            if (!canvas || !histogramData.value.length) {
              console.warn(
                "[Dialog] Cannot draw histogram - canvas:",
                !!canvas,
                "data length:",
                histogramData.value.length
              );
              return;
            }

            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            const ctx = canvas.getContext("2d");
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;
            const data = histogramData.value;

            ctx.clearRect(0, 0, width, height);

            // 对数转换
            const logData = data.map((v) => (v > 0 ? Math.log10(v + 1) : 0));
            const maxLog = Math.max(...logData);

            if (maxLog === 0) return;

            // 绘制直方图
            const barWidth = width / data.length;
            ctx.fillStyle = "#409eff";

            logData.forEach((value, index) => {
              const barHeight = (value / maxLog) * height;
              const x = index * barWidth;
              const y = height - barHeight;
              ctx.fillRect(x, y, Math.max(barWidth - 1, 1), barHeight);
            });

            // 绘制阈值线
            const range = histogramMaxValue.value - histogramMinValue.value;
            if (range === 0) return;

            const minX =
              ((rigMarkMin.value - histogramMinValue.value) / range) * width;
            const maxX =
              ((rigMarkMax.value - histogramMinValue.value) / range) * width;

            ctx.strokeStyle = "#f56c6c";
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            ctx.beginPath();
            ctx.moveTo(minX, 0);
            ctx.lineTo(minX, height);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(maxX, 0);
            ctx.lineTo(maxX, height);
            ctx.stroke();
          }

          async function updatePreview() {
            if (!sessionId) return;

            try {
              await window.electronAPI.invoke(
                "viz:update-preview-mask",
                sessionId,
                rigMarkMin.value,
                rigMarkMax.value,
                previewColor.value
              );
            } catch (error) {
              console.error("[Dialog] Update preview error:", error);
            }
          }

          function cancel() {
            window.electronAPI.send("dialog:close", { action: "cancel" });
          }

          function apply() {
            window.electronAPI.send("dialog:close", {
              action: "apply",
              data: {
                min: rigMarkMin.value,
                max: rigMarkMax.value,
                color: previewColor.value,
              },
            });
          }

          // 绑定关闭按钮事件（Vue 模板中的按钮已经通过 @click 绑定）
          setTimeout(() => {
            document
              .getElementById("close-btn")
              ?.addEventListener("click", cancel);
          }, 100);

          return {
            rigMarkMin,
            rigMarkMax,
            histogramMinValue,
            histogramMaxValue,
            previewColor,
            cancel,
            apply,
          };
        },
      });

      app.use(ElementPlus);
      app.mount("#app");
    </script>
  </body>
</html>
