# APR 裁切功能使用说明

## 功能概述

APR裁切功能允许在三视图（Axial、Coronal、Sagittal）中绘制和调整一个3D裁切框，然后从虚拟体数据中裁切出指定区域，生成新的体数据。

## 核心设计

### 虚拟坐标系统
- 裁切框基于**虚拟坐标系统**，存储6个值：`xStart`, `xEnd`, `yStart`, `yEnd`, `zStart`, `zEnd`
- 虚拟坐标是用户看到的坐标系统，旋转、平移等操作都在这个坐标系中进行
- 裁切时，虚拟坐标会通过旋转矩阵映射到实际体数据坐标进行采样

### 三视图联动
- 统一的3D裁切框在三个视图中显示不同平面的投影：
  - **Axial视图**（轴位）：显示XY平面投影
  - **Coronal视图**（冠状）：显示XZ平面投影  
  - **Sagittal视图**（矢状）：显示YZ平面投影
- 在任一视图中修改裁切框，其他视图会**自动更新**

## 操作方法

### 1. 启用裁切框
```cpp
APR_SetCropBox(width, height, depth);  // 初始化为体数据中心50%大小
APR_EnableCropBox(true);               // 启用显示
```

### 2. 键盘控制
- **B键**：切换裁切框显示/隐藏
- **C键**（在窗口中按）：执行裁切操作

### 3. 鼠标交互

#### 调整裁切框大小
- **拖动角点**（红色方块）：同时调整两个方向的边界
- **拖动边缘中点**（青色方块）：调整单个方向的边界

#### 移动裁切框
- **Shift + 鼠标左键拖动**（在框内）：移动整个裁切框位置，保持大小不变

### 4. 视图联动示例
```
场景：在Axial视图中拖动裁切框的右下角
结果：
  - Axial视图：XY平面的框变大
  - Coronal视图：XZ平面的框X方向同步变化
  - Sagittal视图：YZ平面的框Y方向同步变化
```

## API使用

### 初始化裁切框
```cpp
// 参数：体数据的宽、高、深
APR_SetCropBox(int volumeWidth, int volumeHeight, int volumeDepth);
```

### 执行裁切
```cpp
// 从源APR裁切，返回新的APR句柄
APRHandle croppedAPR = APR_CropVolume(APRHandle sourceHandle);

// 获取最近一次裁切的结果（不创建新的）
APRHandle lastCropped = APR_GetLastCroppedVolume();
```

### 获取裁切框范围
```cpp
float xStart, xEnd, yStart, yEnd, zStart, zEnd;
APR_GetCropBox(&xStart, &xEnd, &yStart, &yEnd, &zStart, &zEnd);
```

### 显示裁切结果
裁切完成后，可以：
1. **创建新窗口**显示裁切后的体数据
2. **替换现有窗口**的APR
3. **保存裁切结果**到文件

```cpp
// 示例：创建新的三视图显示裁切结果
APRHandle croppedAPR = APR_GetLastCroppedVolume();
if (croppedAPR) {
    // 创建新窗口
    WindowHandle newWin = Window_Create(512, 512, "Cropped Volume");
    
    // 创建新的APR（使用裁切后的体数据）
    APRHandle newAPR = APR_Create();
    APR_SetVolume(newAPR, croppedAPR->volume);
    APR_SetSliceDirection(newAPR, 0);  // Axial
    
    // 绑定并显示
    Window_BindRenderer(newWin, newAPR, 2);
}
```

## 裁切逻辑

### 坐标转换流程
```
虚拟坐标（裁切框边界）
    ↓
应用旋转矩阵（R = Rz * Ry * Rx）
    ↓
实际体数据坐标
    ↓
采样数据值
    ↓
新体数据
```

### 旋转支持
裁切功能**完全支持旋转**的体数据：
- 裁切框在虚拟坐标系中定义
- 裁切时自动考虑当前的旋转角度
- 采样时通过旋转矩阵映射到实际坐标

### 边界处理
- 自动限制在有效范围内：`[0, width/height/depth-1]`
- 确保 `start < end`
- 边界外的采样点值为0

## 注意事项

1. **内存管理**
   - 每次裁切会创建新的体数据副本
   - 旧的裁切结果会被自动释放
   - 使用完后记得调用 `APR_Destroy()` 释放资源

2. **性能考虑**
   - 裁切操作涉及体数据复制和旋转变换，可能较慢
   - 对于大体数据（如512x512x300），裁切可能需要几秒钟
   - 裁切过程会在控制台输出进度信息

3. **坐标系统**
   - 窗口坐标：Y从上往下
   - OpenGL坐标：Y从下往上（渲染时自动转换）
   - 虚拟坐标：与体数据坐标一致

4. **裁切框显示**
   - 角点：红色方块（拖动调整两个方向）
   - 边缘中点：青色方块（拖动调整一个方向）
   - 框线：绿色
   - 控制点大小：10像素

## 完整示例

```cpp
// 1. 加载体数据
VolumeHandle volume = Dicom_Volume_Create();
// ... 加载DICOM文件 ...

// 2. 创建APR三视图
APRHandle aprAxial = APR_Create();
APRHandle aprCoronal = APR_Create();
APRHandle aprSagittal = APR_Create();

APR_SetVolume(aprAxial, volume);
APR_SetVolume(aprCoronal, volume);
APR_SetVolume(aprSagittal, volume);

APR_SetSliceDirection(aprAxial, 0);    // Axial
APR_SetSliceDirection(aprCoronal, 1);  // Coronal
APR_SetSliceDirection(aprSagittal, 2); // Sagittal

// 3. 初始化裁切框
int width, height, depth;
Dicom_Volume_GetDimensions(volume, &width, &height, &depth);
APR_SetCropBox(width, height, depth);
APR_EnableCropBox(true);

// 4. 链接三视图（共享中心点）
APRHandle aprs[] = { aprAxial, aprCoronal, aprSagittal };
APR_LinkCenter(aprs, 3);

// 5. 在事件循环中处理C键
if (key == GLFW_KEY_C && g_aprCropBox.enabled) {
    APRHandle cropped = APR_CropVolume(aprAxial);
    if (cropped) {
        printf("裁切成功！可以创建新窗口显示\n");
        // 创建新窗口或替换现有窗口...
    }
}

// 6. 清理资源
APR_Destroy(aprAxial);
APR_Destroy(aprCoronal);
APR_Destroy(aprSagittal);
if (croppedAPR) APR_Destroy(croppedAPR);
```

## 常见问题

**Q: 为什么三个视图的裁切框不联动？**  
A: 确保使用的是最新版本，裁切框现在基于统一的虚拟坐标系统，应该是完全联动的。

**Q: 裁切后的图像是黑色的？**  
A: 检查裁切框范围是否合理，以及窗宽窗位设置是否适合新的数据范围。

**Q: 裁切速度很慢？**  
A: 裁切涉及旋转变换和数据复制，对于大体数据是正常的。可以先缩小裁切区域测试。

**Q: 如何保存裁切结果？**  
A: 可以使用DICOM API将裁切后的体数据保存为新的DICOM系列。
